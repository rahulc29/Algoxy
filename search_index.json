[["index.html", "Elementary Algorithms Solutions About", " Elementary Algorithms Solutions Rahul Chhabra 2022-03-13 About Solutions to the text “Elementary Algorithms”. For fun, non-serious learning project. The text is particularly cool because it uses both functional and imperative techniques. I’ve been wanting to get better at FP for a while - so why not actually do something in it? Other options include using Elm for building an HTML UI (not particularly interesting if you don’t already have a good idea), using F# and Suave to build servers on ASP.NET (requires more knowledge of Kleisli categories and monads than I currently possess), or write a small computer algebra system (something I plan on doing eventually). Studying a few standard data structures is a particularly good option then. Solutions are available online on my Github pages. "],["lists.html", "Chapter 1 Lists 1.1 Equality of Lists", " Chapter 1 Lists Firstly, we present a few perspectives to think about lists : ## Perspectives 1.0.1 High-level Declarative Perspective We’d pick a functional language for this, and this is where algebraic types come in : type List&lt;&#39;a&gt; = Empty | Node of &#39;a * List&lt;&#39;a&gt; The | operator represents disjoint union and * represents cartesian product. 1.0.2 High-level Imperative Perspective Let’s say we’re in a garbage collected language with references and inheritance. We can easily do this in a language like Kotlin : sealed class List&lt;T&gt; { class Empty&lt;T&gt; : List&lt;T&gt;() class Node&lt;T&gt;(val data: T, val next: List&lt;T&gt;): List&lt;T&gt;() } This is not as pretty as the Declarative Perspective but at least there’s pattern matching! when (list) { is List.Node&lt;Int&gt; -&gt; list.data is List.Empty&lt;*&gt; -&gt; null } // return type of when is `Int?` 1.0.3 Low-level Imperative Perspective Let us start by implementing a simple list imperatively, in Rust. struct List&lt;T&gt; { data: T, next: Box&lt;List&lt;T&gt;&gt; } This code is not particularly generic, making it for more generic requires the use of lifetimes : struct List&lt;T, &#39;a&gt; { data: T, next: &amp;&#39;a List&lt;T, &#39;a&gt; } Also, we have currently used one single lifetime 'a for all nodes in our list. We might want to change it later. Do note that this List is immutable. This is intentional : by default, everything in Rust is immutable. We can make it mutable as follows : struct List&lt;T, &#39;a&gt; { data: T, next: &amp;mut &#39;a List&lt;T, &#39;a&gt; } We can also implement this type algebraically : enum List&lt;T, &#39;a&gt; { Empty, Node { data: T, next: &amp;&#39;a List&lt;T, &#39;a&gt; } } Also, we are currently constrained in using only one kind of reference (native &amp; and &amp;mut). In reality, we would want our List to be polymorphic over all possible kinds of references. We can do this with Rust’s Deref trait. enum List&lt;T&gt; { Empty, Node { data: T, next: dyn Deref&lt;Target = List&lt;T&gt;&gt; } } The low-level implementation certainly requires a lot more work due to the lack of the garbage collector! 1.1 Equality of Lists For list of type \\(A\\), suppose we can test if any two elements \\(x\\), \\(y\\) \\(\\in\\) \\(A\\) are equal, define an algorithm to test if two lists are identical. First we define a recursive algorithm with HLFP : let rec Equals a b elementEquals = match a with | [] -&gt; match b with | [] -&gt; true | head::tail -&gt; false | aHead::aTail -&gt; match b with | [] -&gt; false | bHead::bTail -&gt; (elementEquals aHead bHead) &amp;&amp; (Equals aTail bTail elementEquals) This algorithm is elegant and readable but suffers from consuming \\(O(n)\\) stack space. Let us make it tail-recursive! let Equals a b elementEquals = let rec Loop a b result = if !result then result else match a with | [] -&gt; match b with | [] -&gt; true | head::tail -&gt; false | aHead::aTail -&gt; match b with | [] -&gt; false | bHead::bTail -&gt; Loop aTail bTail (result &amp;&amp; (elementEquals aHead bHead)) Loop a b true To summarise, we check if the heads are equal, if yes, we recursively do the same for the tails. In Rust we might do this : fn &lt;T&gt; equals(a: &amp;List&lt;T&gt;, b: &amp;List&lt;T&gt;) -&gt; bool where T : Eq { match a { Empty =&gt; { match b { Empty =&gt; true Node(_, _) =&gt; false } } Node(a_head, a_tail) =&gt; { match b { Empty =&gt; false Node(b_head, b_tail) =&gt; (b_head == a_head) &amp;&amp; equals(a_tail, b_tail) } } } } Rust allows mutations, and we can exploit that to make an iterative version fn &lt;T&gt; equals(a: &amp;List&lt;T&gt;, b: &amp;List&lt;T&gt;) -&gt; bool where T : Eq { let mut result = true; let mut a_eff = a; let mut b_eff = b; while (result) { match a_eff { Empty =&gt; match b_eff { Empty =&gt; { result = true; break; } Node(_, _) =&gt; { result = false; } } Node(a_head, a_tail) =&gt; { match b_eff { Empty =&gt; { result = false; } Node(b_head, b_tail) =&gt; { if (a_head != b_head) { result = false; break; } a_eff = a_tail; b_eff = b_tail; } } } } } return result; } "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
