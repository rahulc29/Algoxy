[["index.html", "Elementary Algorithms Solutions About", " Elementary Algorithms Solutions Rahul Chhabra 2022-03-13 About Solutions to the text “Elementary Algorithms”. For fun, non-serious learning project. The text is particularly cool because it uses both functional and imperative techniques. I’ve been wanting to get better at FP for a while - so why not actually do something in it? Other options include using Elm for building an HTML UI (not particularly interesting if you don’t already have a good idea), using F# and Suave to build servers on ASP.NET (requires more knowledge of Kleisli categories and monads than I currently possess), or write a small computer algebra system (something I plan on doing eventually). Studying a few standard data structures is a particularly good option then. Solutions are available online on my Github pages. "],["lists.html", "Chapter 1 Lists 1.1 Perspectives 1.2 Equality of Lists 1.3 Length 1.4 Indices 1.5 Last and Init 1.6 Reverse Index", " Chapter 1 Lists Firstly, we present a few perspectives to think about lists : 1.1 Perspectives 1.1.1 High-level Declarative Perspective We’d pick a functional language for this, and this is where algebraic types come in : type List&lt;&#39;a&gt; = Empty | Node of &#39;a * List&lt;&#39;a&gt; The | operator represents disjoint union and * represents cartesian product. 1.1.2 High-level Imperative Perspective Let’s say we’re in a garbage collected language with references and inheritance. We can easily do this in a language like Kotlin : sealed class List&lt;T&gt; { class Empty&lt;T&gt; : List&lt;T&gt;() class Node&lt;T&gt;(val data: T, val next: List&lt;T&gt;): List&lt;T&gt;() } This is not as pretty as the Declarative Perspective but at least there’s pattern matching! when (list) { is List.Node&lt;Int&gt; -&gt; list.data is List.Empty&lt;*&gt; -&gt; null } // return type of when is `Int?` We will also sometimes use the following formulation, especially for mutating algorithms: class ListNode&lt;T&gt;(var value: T, var next: ListNode&lt;T&gt;?) 1.1.3 Low-level Imperative Perspective Let us start by implementing a simple list imperatively, in Rust. struct List&lt;T&gt; { data: T, next: Box&lt;List&lt;T&gt;&gt; } This code is not particularly generic, making it for more generic requires the use of lifetimes : struct List&lt;T, &#39;a&gt; { data: T, next: &amp;&#39;a List&lt;T, &#39;a&gt; } Also, we have currently used one single lifetime 'a for all nodes in our list. We might want to change it later. Do note that this List is immutable. This is intentional : by default, everything in Rust is immutable. We can make it mutable as follows : struct List&lt;T, &#39;a&gt; { data: T, next: &amp;mut &#39;a List&lt;T, &#39;a&gt; } This List is actually infinite because references in Rust are non-nullable, to mitigate this we implement this type algebraically : enum List&lt;T, &#39;a&gt; { Empty, Node { data: T, next: &amp;&#39;a List&lt;T, &#39;a&gt; } } Also, we are currently constrained in using only one kind of reference (native &amp; and &amp;mut). In reality, we would want our List to be polymorphic over all possible kinds of references. We can do this with Rust’s Deref trait. enum List&lt;T&gt; { Empty, Node { data: T, next: dyn Deref&lt;Target = List&lt;T&gt;&gt; } } Another way to implement a List&lt;T&gt; is to use the Option&lt;T&gt; monad in Rust. struct List&lt;T&gt; { data: T, next: Option&lt;Box&lt;List&lt;T&gt;&gt;&gt; } We use Box&lt;T&gt; because using a generic Deref is unsized and Option requires a sized type argument. Of course, Box&lt;T&gt; is a sized implementation of Deref but that would require the following constraints : struct List&lt;T, R&gt; where R : Deref&lt;Target = List&lt;T&gt;&gt; + Sized { data: T, next: Option&lt;Box&lt;List&lt;T&gt;&gt;&gt; } The low-level implementation certainly requires a lot more work due to the lack of the garbage collector! 1.2 Equality of Lists Exercise 1.1 For list of type \\(A\\), suppose we can test if any two elements \\(x\\), \\(y\\) \\(\\in\\) \\(A\\) are equal, define an algorithm to test if two lists are identical. Solution. First we define a recursive algorithm with HLFP : let rec Equals a b elementEquals = match a with | [] -&gt; match b with | [] -&gt; true | head::tail -&gt; false | aHead::aTail -&gt; match b with | [] -&gt; false | bHead::bTail -&gt; (elementEquals aHead bHead) &amp;&amp; (Equals aTail bTail elementEquals) This algorithm is elegant and readable but suffers from consuming \\(O(n)\\) stack space. Let us make it tail-recursive! let Equals a b elementEquals = let rec Loop a b result = if !result then result else match a with | [] -&gt; match b with | [] -&gt; true | head::tail -&gt; false | aHead::aTail -&gt; match b with | [] -&gt; false | bHead::bTail -&gt; Loop aTail bTail (result &amp;&amp; (elementEquals aHead bHead)) Loop a b true To summarise, we check if the heads are equal, if yes, we recursively do the same for the tails. In Rust we might do this : fn &lt;T&gt; equals(a: &amp;List&lt;T&gt;, b: &amp;List&lt;T&gt;) -&gt; bool where T : Eq { match a { Empty =&gt; { match b { Empty =&gt; true Node(_, _) =&gt; false } } Node(a_head, a_tail) =&gt; { match b { Empty =&gt; false Node(b_head, b_tail) =&gt; (b_head == a_head) &amp;&amp; equals(a_tail, b_tail) } } } } Rust allows mutations, and we can exploit that to make an iterative version fn &lt;T&gt; equals(a: &amp;List&lt;T&gt;, b: &amp;List&lt;T&gt;) -&gt; bool where T : Eq { let mut result = true; let mut a_eff = a; let mut b_eff = b; while (result) { match a_eff { Empty =&gt; match b_eff { Empty =&gt; { result = true; break; } Node(_, _) =&gt; { result = false; } } Node(a_head, a_tail) =&gt; { match b_eff { Empty =&gt; { result = false; } Node(b_head, b_tail) =&gt; { if (a_head != b_head) { result = false; break; } a_eff = a_tail; b_eff = b_tail; } } } } } return result; } The iterative version is (expectedly) less pretty. The iterative Rust version is what you would get after applying the Tail-Call Opitimization to the tail-recursive formulation. 1.3 Length Length is easily computed recursively : let rec Length list = match list with | [] -&gt; 0 | head::tail -&gt; 1 + Length tail This consume \\(O(n)\\) stack space though. Tail-recursive version : let Length list = let rec Loop list answer = match list with | [] -&gt; answer | head::tail -&gt; Loop tail (answer + 1) Loop list 0 Iterative version : fn &lt;T&gt; length(list: &amp;List&lt;T&gt;) -&gt; usize { let mut answer = 0usize; let mut current = list.next.as_ref(); while current.is_some() { answer += 1; current = current.unwrap().next.as_ref(); } return answer; } Observe that we are only performing borrows and there are no moves. The default semantics in Rust are move semantics, so we explicitly use .as_ref() to make sure we’re only borrowing. 1.4 Indices To get the element at the \\(i\\)th index we perform the following computation: exception ListIndexException let rec ElementAt list index = match list with | [] -&gt; raise ListIndexException | head::tail -&gt; if index = 0 then head else ElementAt tail (index - 1) Any index \\(i\\) is either the \\(0\\)th index of a list or the \\(i-1\\)th index of the sublist. Conveniently for us, this code is already tail-recursive. Iterative version: fn index&lt;&#39;a, T&gt;(list: Option&lt;&amp;&#39;a List&lt;&#39;a, T&gt;&gt;, index: usize) -&gt; Result&lt;&amp;&#39;a T, String&gt; { if let None = list { return Err(String::from(&quot;Indexing undefined for empty lists&quot;)); } let mut current = list; let mut i = index; while current.is_some() { if i == 0 { return Ok(&amp;current.unwrap().data); } i -= 1; current = current.unwrap().next; } // got to none // irrespective of i it is an out of bounds return Err(format!(&quot;Index {} is out of bounds&quot;, i)); } Here we have used the generic-lifetime-bound implementation in Rust. The reason for doing this is simple : we need to ensure that the lifetime of the returned reference live alongside the list. This is easier to do using parameterised lifetimes than using Box&lt;T&gt;. We use the Result&lt;T, E&gt; type to signify that the computation may fail. Exercise 1.2 In the iterative index(list, index) algorithm, what is the behavior when list is empty? What is the behavior when index is out of the bound or negative? Solution. For the iterative Rust variant, we have used the struct definition based on Option, as such, truely empty lists are impossible. To represent empty lists, we set Option&lt;&amp;List&lt;'a, T&gt;&gt; = None. This case is accounted for and erred over. If index is out of bounds, we get an Err variant in the Result. We will now use only functional and Kotlin code except when the imperative needs to be studied extensively. The reason is that Rust’s type system will get in our way so it is better to satisfy the type system later. 1.5 Last and Init To compute the last element : exception UndefinedException let rec Last list = match list with | [] -&gt; raise UndefinedException | head::tail -&gt; match tail with | [] -&gt; head | _::subTail -&gt; Last subTail This function is already tail-recursive so we need not care any further :D In Kotlin : fun&lt;T&gt; last(list: ListNode&lt;T&gt;): T { var current = list var next = current.next while (next != null) { next = list.next current = current.next } return current.value } We use the ListNode&lt;T&gt; formulation since this algorithm is rather mutation heavy. To compute the init of a list (the sublist before the last element) exception UndefinedException let rec Init list = match list with | [] -&gt; raise UndefinedException | head::tail -&gt; match tail with | [] -&gt; [] | _::_ -&gt; head::(Init tail) We will return to an iterative version later after covering how to reverse a list. 1.6 Reverse Index "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
